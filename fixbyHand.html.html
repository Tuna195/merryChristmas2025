<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 5: Letters & Photos</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        .input_video { display: none; }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }
        #status-bar {
            padding: 10px; color: #00ff00; font-family: monospace; 
            background: rgba(0,0,0,0.6); font-size: 14px; text-align: center;
        }
        #instructions {
            padding: 20px; color: #fff; font-family: 'Segoe UI', sans-serif; 
            text-align: center; text-shadow: 0 0 10px #00aaff; font-weight: bold; opacity: 0.9;
        }
        .key-guide { font-size: 1.3rem; margin-bottom: 8px; }
        .sub-guide { font-size: 1rem; color: #ddd; }
        
        /* Loading */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #fff; display: flex; justify-content: center; align-items: center;
            z-index: 999; font-family: sans-serif; flex-direction: column;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #00ff00;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <h2>ƒêang kh·ªüi ƒë·ªông AI & T·∫£i ·∫£nh...</h2>
        <p>Vui l√≤ng c·∫•p quy·ªÅn Camera</p>
    </div>

    <div id="ui-layer">
        <div id="status-bar">üî¥ ƒêang t√¨m tay...</div>
        <div id="instructions">
            <div class="key-guide">üñêÔ∏è X√íE TAY: Hi·ªán C√¢y | ‚úä N·∫ÆM TAY: H√≥a C·∫ßu</div>
            <div class="sub-guide">üëå DI CHUY·ªÇN tay qua l·∫°i ƒë·ªÉ ch·ªçn QU√Ä ho·∫∑c TH∆Ø</div>
            <div class="sub-guide" style="font-size: 0.9rem; color: #aaa; margin-top:5px;">(Gi·ªØ ng√≥n tay 1.5s ƒë·ªÉ m·ªü)</div>
        </div>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ==========================================
        // 1. C·∫§U H√åNH TR·∫†NG TH√ÅI
        // ==========================================
        const STATE = {
            handDetected: false,
            handX: 0.5,
            handY: 0.5,
            isPinching: false,
            activeItem: null, // 'GIFT_L', 'LETTER_1', 'GIFT_C', 'LETTER_2', 'GIFT_R'
            pinchStartTime: 0,
            isHandOpen: false,
            // L∆∞u ph·∫°m vi index c·ªßa c√°c h·∫°t (ƒë·ªÉ l√†m hi·ªáu ·ª©ng n·ªï ri√™ng l·∫ª)
            itemRanges: {
                gift_l: [0, 0],
                letter_1: [0, 0],
                gift_c: [0, 0],
                letter_2: [0, 0],
                gift_r: [0, 0]
            },
            lastMode: 'SPHERE',
        };
        let hoverStartTime = 0;       // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ch·∫°m
        let currentHoverIndex = -1;   // ƒêang ch·∫°m v√†o m√≥n qu√† n√†o (index)
        const HOVER_DELAY = 1500;     // 1.5 gi√¢y (t√≠nh b·∫±ng mili gi√¢y)

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 45); // Camera l√πi xa ch√∫t ƒë·ªÉ nh√¨n bao qu√°t

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const treeGroup = new THREE.Group();
        treeGroup.position.y = 3;
        scene.add(treeGroup);

        // ==========================================
        // 2. T·∫†O HOLOGRAM T·ª™ TEXT & ·∫¢NH
        // ==========================================
        // H√†m t·∫°o text (ƒê√É S·ª¨A M√ÄU L·ªÑ H·ªòI)
        function createTextPositions(text, pCount, isHeart = false) {
            const canvas = document.createElement('canvas');
            const size = 1024; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; ctx.fillRect(0,0,size,size);
            
            // D√πng m√†u tr·∫Øng ƒë·ªÉ v·∫Ω l√™n canvas l·∫•y v·ªã tr√≠ (m√†u s·∫Øc th·∫≠t s·∫Ω random b√™n d∆∞·ªõi)
            ctx.fillStyle = '#ffffff'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            if (isHeart) {
                ctx.font = '800px sans-serif'; ctx.fillText('‚ô•', size/2, size/2 + 50);
            } else {
                ctx.font = 'bold 150px Arial';
                if (text.includes("XMAS")) {
                    ctx.fillText("MERRY", size/2, size/2 - 70); ctx.fillText("CHRISTMAS", size/2, size/2 + 80);
                } else {
                    ctx.fillText(text, size/2, size/2);
                }
            }
            
            // L·∫•y d·ªØ li·ªáu v·ªã tr√≠ v√† m√†u g·ªëc (ƒëang l√† tr·∫Øng)
            const data = scanPixelsAndColors(ctx, size, pCount);

            // --- ƒêO·∫†N CODE TH√äM M·ªöI: TR·ªòN M√ÄU L·ªÑ H·ªòI ---
            // Danh s√°ch m√†u: V√†ng, Cam, Tr·∫Øng, ƒê·ªè, H·ªìng (H·ªá m√†u 0.0 -> 1.0)
            const festivalColors = [
                {r:1.0, g:0.84, b:0.0}, // V√†ng (Gold)
                {r:1.0, g:0.64, b:0.0}, // Cam (Orange)
                {r:1.0, g:1.0,  b:1.0}, // Tr·∫Øng
                {r:1.0, g:0.0,  b:0.2}, // ƒê·ªè
                {r:1.0, g:0.41, b:0.71} // H·ªìng (Pink)
            ];

            // G√°n l·∫°i m√†u ng·∫´u nhi√™n cho t·ª´ng h·∫°t c·ªßa ch·ªØ
            for(let i=0; i < pCount; i++) {
                // Ch·ªçn ng·∫´u nhi√™n 1 m√†u
                const rnd = festivalColors[Math.floor(Math.random() * festivalColors.length)];
                
                // G√°n v√†o m·∫£ng m√†u (R, G, B)
                data.colors[i*3]     = rnd.r; 
                data.colors[i*3 + 1] = rnd.g; 
                data.colors[i*3 + 2] = rnd.b; 
            }
            // ------------------------------------------

            return data;
        }

        // H√†m t·∫°o v·ªã tr√≠ + M√ÄU S·∫ÆC t·ª´ URL ·∫¢nh (ƒê√É S·ª¨A)
        function createImagePositions(url, pCount, targetPosArray, targetColArray) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const size = 1024; canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000'; ctx.fillRect(0,0,size,size);
                
                const scale = Math.min(size/img.width, size/img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                ctx.drawImage(img, (size-w)/2, (size-h)/2, w, h);

                // L·∫•y c·∫£ v·ªã tr√≠ v√† m√†u
                const data = scanPixelsAndColors(ctx, size, pCount);
                
                // Copy sang m·∫£ng ƒë√≠ch
                for(let i=0; i<pCount; i++) {
                    // Copy v·ªã tr√≠
                    targetPosArray[i*3]   = data.positions[i*3];
                    targetPosArray[i*3+1] = data.positions[i*3+1];
                    targetPosArray[i*3+2] = data.positions[i*3+2];
                    
                    // Copy m√†u (N·∫øu ·∫£nh c√≥ m√†u th√¨ l·∫•y, kh√¥ng th√¨ m·∫∑c ƒë·ªãnh tr·∫Øng)
                    targetColArray[i*3]   = data.colors[i*3];   // R
                    targetColArray[i*3+1] = data.colors[i*3+1]; // G
                    targetColArray[i*3+2] = data.colors[i*3+2]; // B
                }
                console.log("ƒê√£ load ·∫£nh m√†u xong:", url);
            };
            img.src = url;
        }

        // H√†m qu√©t pixel l·∫•y c·∫£ v·ªã tr√≠ v√† m√†u RGB
        function scanPixelsAndColors(ctx, size, pCount) {
            const imgData = ctx.getImageData(0,0,size,size);
            const pixels = [];
            for(let i=0; i<size; i+=6) { // B∆∞·ªõc nh·∫£y nh·ªè (6) ƒë·ªÉ l·∫•y nhi·ªÅu chi ti·∫øt h∆°n
                for(let j=0; j<size; j+=6) {
                    const idx = (i*size + j) * 4;
                    const r = imgData.data[idx] / 255;
                    const g = imgData.data[idx+1] / 255;
                    const b = imgData.data[idx+2] / 255;
                    const brightness = (r+g+b)/3;

                    if(brightness > 0.1) { // L·∫•y c√°c ƒëi·ªÉm c√≥ ƒë·ªô s√°ng > 10%
                        pixels.push({
                            x: (j/size - 0.5) * 45,
                            y: -(i/size - 0.5) * 45,
                            c: {r: r, g: g, b: b} // L∆∞u m√†u
                        });
                    }
                }
            }
            
            const positions = new Float32Array(pCount * 3);
            const colors = new Float32Array(pCount * 3);

            for(let i=0; i<pCount; i++) {
                const p = pixels[i % pixels.length] || {x:0, y:0, c:{r:1, g:1, b:1}}; 
                // V·ªã tr√≠
                positions[i*3] = p.x + (Math.random()-0.5)*0.3;
                positions[i*3+1] = p.y + (Math.random()-0.5)*0.3;
                positions[i*3+2] = (Math.random()-0.5) * 2; 
                // M√†u s·∫Øc
                colors[i*3] = p.c.r;
                colors[i*3+1] = p.c.g;
                colors[i*3+2] = p.c.b;
            }
            return { positions, colors };
        }

        // ==========================================
        // ==========================================
        // 3. T·∫†O H·∫†T & DATA (C√ì H·∫†T CH√ÇU & TUY·∫æT R∆†I)
        // ==========================================
        const particleCount = 100000; 
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = [];

        // C√°c m·∫£ng ƒë√≠ch
        const posSphere = new Float32Array(particleCount * 3);
        const posTree = new Float32Array(particleCount * 3);
        const baseColors = new Float32Array(particleCount * 3);
        
        // Bi·∫øn ƒë√°nh d·∫•u v·ªã tr√≠ b·∫Øt ƒë·∫ßu c·ªßa c√°c h·∫°t l√†m tuy·∫øt (ƒë·ªÉ ƒëi·ªÅu khi·ªÉn r∆°i)
        let snowStartIndex = 0; 

        // Helper load text
        function initTextData(text, count, isHeart) {
            const data = createTextPositions(text, count, isHeart); 
            return { pos: data.positions, col: data.colors };
        }

        // --- 1. DATA V·∫¨T PH·∫®M ---
        const dGiftL = initTextData("I LOVE YOU", particleCount, false);
        const posTargetGiftL = dGiftL.pos; const colTargetGiftL = dGiftL.col;

        const dGiftC = initTextData("MERRY XMAS", particleCount, false);
        const posTargetGiftC = dGiftC.pos; const colTargetGiftC = dGiftC.col;

        const dGiftR = initTextData("", particleCount, true);
        const posTargetGiftR = dGiftR.pos; const colTargetGiftR = dGiftR.col;
        
        const posTargetLetter1 = new Float32Array(particleCount * 3); 
        const colTargetLetter1 = new Float32Array(particleCount * 3);
        const posTargetLetter2 = new Float32Array(particleCount * 3);
        const colTargetLetter2 = new Float32Array(particleCount * 3);

        for(let i=0; i<particleCount*3; i++) {
            posTargetLetter1[i] = posTargetGiftC[i]; posTargetLetter2[i] = posTargetGiftC[i];
            colTargetLetter1[i] = 1.0; colTargetLetter2[i] = 1.0;
        }
        
        const imgUrl1 = "https://raw.githubusercontent.com/Tuna195/merryChristmas2025/c0137de89120f3f2722458b53dc858650fc56218/assets/anhchristmas-removebg-preview.png"; 
        const imgUrl2 = "https://raw.githubusercontent.com/Tuna195/merryChristmas2025/02aa97f065defe174c3d3bd3fe7c1545ee554f43/assets/anh3-removebg-preview.png"; 
        
        createImagePositions(imgUrl1, particleCount, posTargetLetter1, colTargetLetter1);
        createImagePositions(imgUrl2, particleCount, posTargetLetter2, colTargetLetter2);

        // --- 2. X√ÇY D·ª∞NG SCENE ---
        let pIdx = 0;
        const C = {
            white: new THREE.Color(0xffffff), gold: new THREE.Color(0xffcc00),
            red: new THREE.Color(0xff0033), green: new THREE.Color(0x00aa00),
            blue: new THREE.Color(0x0088ff), tree: new THREE.Color(0x004400),
            brown: new THREE.Color(0x8B4513), orange: new THREE.Color(0xff6600),
            paper: new THREE.Color(0xffffee), snow: new THREE.Color(0xaaddff)
        };

        function addPoint(x, y, z, col) {
            if(pIdx >= particleCount) return;
            // G√°n v·ªã tr√≠ C√¢y
            posTree[pIdx*3] = x; posTree[pIdx*3+1] = y; posTree[pIdx*3+2] = z;
            
            // G√°n v·ªã tr√≠ C·∫ßu
            const u=Math.random(), v=Math.random();
            const th=2*Math.PI*u, ph=Math.acos(2*v-1);
            const r=20+Math.random()*15 * 0.6;
            posSphere[pIdx*3] = r*Math.sin(ph)*Math.cos(th);
            posSphere[pIdx*3+1] = r*Math.sin(ph)*Math.sin(th);
            posSphere[pIdx*3+2] = r*Math.cos(ph);

            // Kh·ªüi t·∫°o
            positions[pIdx*3] = posSphere[pIdx*3];
            positions[pIdx*3+1] = posSphere[pIdx*3+1];
            positions[pIdx*3+2] = posSphere[pIdx*3+2];

            colors.push(col.r, col.g, col.b);
            pIdx++;
        }

        // A. C√ÇY TH√îNG
        for(let i=0;i<24000;i++){
            const y=(Math.random()*40)-20, r=((20-y)/3)*1.32, a=Math.random()*Math.PI*2, rad=Math.random()*r;
            const rnd=Math.random(); let c;
            if(rnd<0.05) c=C.red.clone().multiplyScalar(1.5);
            else if(rnd<0.6) c=(Math.random()>0.5?C.gold:new THREE.Color(0xff5500)).clone().multiplyScalar(1.2);
            else if(rnd<0.9) c=C.white; else c=C.tree;
            addPoint(rad*Math.cos(a), y*1.1, rad*Math.sin(a), c);
        }

        // B. NG∆Ø·ªúI TUY·∫æT
        const smX=14, smZ=5, smYBase=-20;
        for(let i=0;i<5000;i++){ 
            const p=Math.random(); let r,cy; if(p<0.45){r=3.5;cy=smYBase+3;}else if(p<0.8){r=2.5;cy=smYBase+7.5;}else{r=1.8;cy=smYBase+11;}
            const u=Math.random(),v=Math.random(),th=2*Math.PI*u,ph=Math.acos(2*v-1), rad=r*(0.85+Math.random()*0.15); 
            addPoint(smX+rad*Math.sin(ph)*Math.cos(th), cy+rad*Math.sin(ph)*Math.sin(th), smZ+rad*Math.cos(ph), C.white);
        }
        for(let side=-1; side<=1; side+=2) { 
            for(let i=0; i<400; i++) { 
                const t=i/400, sx=smX+side*2.5, sy=smYBase+8, sz=smZ, ex=smX+side*6, ey=smYBase+10, ez=smZ+1;
                addPoint(THREE.MathUtils.lerp(sx,ex,t)+(Math.random()-0.5)*0.2, THREE.MathUtils.lerp(sy,ey,t)+(Math.random()-0.5)*0.2, THREE.MathUtils.lerp(sz,ez,t)+(Math.random()-0.5)*0.2, C.brown);
            }
        }
        for(let i=0;i<300;i++){ 
            const t=Math.random(), h=t*1.5, r=(1-t)*0.3, a=Math.random()*Math.PI*2, rad=Math.random()*r;
            addPoint(smX+rad*Math.cos(a), smYBase+11+rad*Math.sin(a), smZ+1.8+h, C.orange);
        }

        // C. V·∫¨T PH·∫®M
        function addGift(key, gx, gz, s, c, cnt) {
            const start = pIdx;
            const gy=-20+s/2;
            for(let i=0;i<cnt;i++){
                let fx=(Math.random()-0.5)*s, fy=(Math.random()-0.5)*s, fz=(Math.random()-0.5)*s;
                if(Math.random()>0.1){ 
                    const ax=Math.floor(Math.random()*3); 
                    if(ax==0)fx=s/2*(Math.random()>0.5?1:-1); else if(ax==1)fy=s/2*(Math.random()>0.5?1:-1); else fz=s/2*(Math.random()>0.5?1:-1);
                }
                addPoint(gx+fx, gy+fy, gz+fz, c);
            }
            STATE.itemRanges[key] = [start, pIdx - 1];
        }
        function addLetter(key, lx, lz, w, h, cnt) {
            const start = pIdx;
            const ly = -19.5;
            for(let i=0; i<cnt; i++) {
                const dx = (Math.random()-0.5)*w;
                const dz = (Math.random()-0.5)*h;
                addPoint(lx+dx, ly + (Math.random()*0.5), lz+dz, C.paper);
                if(i < cnt/8) addPoint(lx+(Math.random()-0.5)*1, ly+0.6, lz+(Math.random()-0.5)*1, C.red);
            }
            STATE.itemRanges[key] = [start, pIdx - 1];
        }
        addGift('gift_l', -12, 0, 4, C.green, 3000);
        addLetter('letter_1', -7, 4, 5, 3.5, 3000);
        addGift('gift_c', -2, 10, 3.5, C.red, 3000);
        addLetter('letter_2', 4, 5, 5, 3.5, 3000);
        addGift('gift_r', 10, 8, 4, C.blue, 3000);

        // --- D. CH√ÇU (ORNAMENTS) - ƒê√É TH√äM L·∫†I ---
        for(let k=0;k<35;k++){ 
            const oy=Math.random()*30 - 15; 
            const or=((20-oy)/3)*1.1; 
            const oa=Math.random()*Math.PI*2; 
            const ox=Math.cos(oa)*or, oz=Math.sin(oa)*or;
            for(let i=0;i<80;i++){
                const u=Math.random(),v=Math.random(),th=2*Math.PI*u,ph=Math.acos(2*v-1),rad=0.6*Math.random();
                addPoint(ox+rad*Math.sin(ph)*Math.cos(th), oy+rad*Math.sin(ph)*Math.sin(th), oz+rad*Math.cos(ph), (Math.random()>0.5?C.gold:C.red).clone().multiplyScalar(1.5));
            }
        }

        // --- E. BACKGROUND: TUY·∫æT R∆†I (H·∫°t d∆∞ th·ª´a) ---
        // L∆∞u l·∫°i v·ªã tr√≠ b·∫Øt ƒë·∫ßu c·ªßa tuy·∫øt
        snowStartIndex = pIdx; 
        console.log("Snow starts at index:", snowStartIndex);

        function addSnowflake(cx, cy, cz, radius) {
            const color = C.snow;
            for(let k=0; k<6; k++) {
                const angle = (k * 60) * Math.PI / 180;
                const dirX = Math.cos(angle);
                const dirY = Math.sin(angle);
                for(let i=0; i<15; i++) {
                    const r = (i/15) * radius;
                    addPoint(cx + r*dirX, cy + r*dirY, cz, color);
                }
                for(let i=5; i<12; i+=3) { 
                    const r = (i/15) * radius;
                    const branchLen = radius * 0.3 * (1 - i/15);
                    addPoint(cx + r*dirX + branchLen*dirY, cy + r*dirY - branchLen*dirX, cz, color);
                    addPoint(cx + r*dirX - branchLen*dirY, cy + r*dirY + branchLen*dirX, cz, color);
                }
            }
        }

        let safeLoop = 0;
        while(pIdx < particleCount && safeLoop < 10000) {
            safeLoop++;
            const x = (Math.random() - 0.5) * 140; 
            const z = (Math.random() - 0.5) * 100; 
            const dist = Math.sqrt(x*x + z*z);
            if(dist < 22) continue; 

            const y = (Math.random() - 0.5) * 90; 
            const size = 0.8 + Math.random() * 1.5;
            
            if(pIdx + 150 < particleCount) {
                addSnowflake(x, y, z, size);
            } else {
                addPoint(x, y, z, C.white);
            }
        }

        // Setup Geometry
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        // [M·ªöI] L∆∞u l·∫°i m√†u g·ªëc c·ªßa c√¢y th√¥ng v√†o m·∫£ng baseColors
        for(let i=0; i<colors.length; i++) {
            baseColors[i] = colors[i];
        }
        function getTex(){const c=document.createElement('canvas');c.width=32;c.height=32;const ctx=c.getContext('2d');const g=ctx.createRadialGradient(16,16,0,16,16,16);g.addColorStop(0,'rgba(255,255,255,1)');g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.fillRect(0,0,32,32);return new THREE.CanvasTexture(c);}
        const particles = new THREE.Points(geometry, new THREE.PointsMaterial({
            size: 0.45, map: getTex(), vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        treeGroup.add(particles);

        // --- Sao & Tuy·∫øt ---
        function getStarTex(){const c=document.createElement('canvas');c.width=128;c.height=128;const ctx=c.getContext('2d');const g=ctx.createRadialGradient(64,64,10,64,64,60);g.addColorStop(0,'#ffd700');g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.fillRect(0,0,128,128);ctx.beginPath();ctx.moveTo(64,29);for(let i=0;i<10;i++){let r=i%2==0?35:16;ctx.lineTo(64+r*Math.cos(Math.PI/2*3+i*Math.PI/5),64+r*Math.sin(Math.PI/2*3+i*Math.PI/5));}ctx.closePath();ctx.fillStyle='#ffff00';ctx.fill();return new THREE.CanvasTexture(c);}
        const star = new THREE.Sprite(new THREE.SpriteMaterial({map:getStarTex(),color:0xffffff,blending:THREE.AdditiveBlending,depthWrite:false}));
        star.position.set(0, 23, 0); star.scale.set(7, 7, 1); treeGroup.add(star);

        const snowCnt=2500, snPos=new Float32Array(snowCnt*3), snVel=[];
        for(let i=0;i<snowCnt;i++){snPos[i*3]=(Math.random()-0.5)*150;snPos[i*3+1]=(Math.random()-0.5)*100;snPos[i*3+2]=(Math.random()-0.5)*150;snVel.push(0.05+Math.random()*0.15);}
        const snowGeo=new THREE.BufferGeometry(); snowGeo.setAttribute('position',new THREE.BufferAttribute(snPos,3));
        scene.add(new THREE.Points(snowGeo, new THREE.PointsMaterial({color:0xffffff,size:0.3,transparent:true,opacity:0.5,map:getTex(),depthWrite:false})));

        // ==========================================
        // 4. AI HAND TRACKING (C·∫¨P NH·∫¨T 5 V√ôNG)
        // ==========================================
        const videoElement = document.querySelector('.input_video');
        const statusBar = document.getElementById('status-bar');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});

        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const lm = results.multiHandLandmarks[0];
                STATE.handX = lm[9].x; 
                STATE.handY = lm[9].y;

                // M·ªü/N·∫Øm
                const wrist=lm[0]; let ext=0; [8,12,16,20].forEach(t=>{if(Math.sqrt(Math.pow(lm[t].x-wrist.x,2)+Math.pow(lm[t].y-wrist.y,2))>0.25)ext++;});
                const isHandOpen = (ext >= 3);
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i b·ªÅn v·ªØng (ƒë·ªÉ nh·ªõ khi b·ªè tay ra)
                if (isHandOpen) {
                    STATE.lastMode = 'TREE'; // X√≤e tay -> Nh·ªõ l√† C√¢y
                } else {
                    STATE.lastMode = 'SPHERE'; // N·∫Øm tay -> Nh·ªõ l√† C·∫ßu
                }
                // Pinch
                const dist = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                const currentlyPinching = (dist < 0.05);
                STATE.isHandOpen = isHandOpen;
                if (currentlyPinching && isHandOpen) {
                    // CHIA 5 V√ôNG (0.0 -> 1.0)
                    let newItem = 'GIFT_C';
                    if (STATE.handX < 0.45 && STATE.handY <= 0.5) newItem = 'GIFT_R';
                    else if (STATE.handX < 0.5 && STATE.handY > 0.5) newItem = 'LETTER_2';
                    else if (STATE.handX < 0.57 && STATE.handY <= 0.5) newItem = 'GIFT_C';
                    else if (STATE.handX >= 0.5 && STATE.handY > 0.5) newItem = 'LETTER_1';
                    else newItem = 'GIFT_L';

                    if (STATE.activeItem !== newItem) {
                        STATE.activeItem = newItem;
                        STATE.pinchStartTime = Date.now();
                    }
                    STATE.isPinching = true;
                } else {
                    STATE.isPinching = false;
                    STATE.activeItem = null;
                    STATE.pinchStartTime = 0;
                }

                // UI Label
                let nameMap = {
                    'GIFT_L': 'QU√Ä TR√ÅI (TEXT)', 'LETTER_1': 'TH∆Ø 1 (·∫¢NH)', 
                    'GIFT_C': 'QU√Ä GI·ªÆA (TEXT)', 'LETTER_2': 'TH∆Ø 2 (·∫¢NH)', 'GIFT_R': 'QU√Ä PH·∫¢I (HEART)'
                };
                statusBar.innerText = `üü¢ TAY: ${isHandOpen?"M·ªû":"N·∫ÆM"} | CH·ªåN: ${nameMap[STATE.activeItem]||"--"} | GI·ªÆ: ${STATE.isPinching ? ((Date.now()-STATE.pinchStartTime)/1000).toFixed(1)+"s" : "0"}`;

            } else {
                STATE.handDetected = false;
                STATE.isPinching = false;
                STATE.activeItem = null;
                statusBar.innerText = "üî¥ ƒêang t√¨m tay...";
            }
        });

        const cam = new Camera(videoElement, {onFrame:async()=>{await hands.send({image:videoElement});}, width:640, height:480});
        cam.start().then(()=>document.getElementById('loading').style.display='none');

        // ==========================================

        // ==========================================
        // üéµ C·∫§U H√åNH NH·∫†C N·ªÄN (AUDIO CONTROL)
        // ==========================================
        // 1. Khai b√°o link nh·∫°c (B·∫°n thay link c·ªßa b·∫°n v√†o ƒë√¢y)
        const bgMusic = new Audio('https://raw.githubusercontent.com/Tuna195/merryChristmas2025/refs/heads/main/Christmas%20is%20Coming%20-%20Written%20Duc%2C%20Beat%20Jake%20Angel%20(Lyrics%20%2B%20Vietsub).mp3');

        // 2. C·∫•u h√¨nh c∆° b·∫£n
        bgMusic.loop = true;   // T·ª± ƒë·ªông ph√°t l·∫°i khi h·∫øt b√†i
        bgMusic.volume = 0.5;  // √Çm l∆∞·ª£ng v·ª´a ph·∫£i (0.0 ƒë·∫øn 1.0)

        // 3. Ch·ªëng Crash: N·∫øu link l·ªói, ch·ªâ b√°o log v√† kh√¥ng l√†m g√¨ c·∫£
        bgMusic.onerror = function() {
            console.warn("‚ö†Ô∏è Link nh·∫°c b·ªã l·ªói ho·∫∑c kh√¥ng truy c·∫≠p ƒë∆∞·ª£c. ƒê√£ b·ªè qua nh·∫°c.");
            // Kh√¥ng g·ªçi l·ªánh alert hay throw error ƒë·ªÉ tr√°nh l√†m phi·ªÅn tr·∫£i nghi·ªám
        };

        // 4. X·ª≠ l√Ω Ph√≠m t·∫Øt (Space: Pause/Play, R: Replay)
        document.addEventListener('keydown', function(e) {
            // Ph√≠m SPACE (D·∫•u c√°ch)
            if (e.code === 'Space') {
                e.preventDefault(); // NgƒÉn trang web b·ªã cu·ªôn xu·ªëng
                if (bgMusic.paused) {
                    // D√πng .catch ƒë·ªÉ tr√°nh l·ªói n·∫øu tr√¨nh duy·ªát ch·∫∑n
                    bgMusic.play().catch(() => console.log("Ch∆∞a th·ªÉ ph√°t nh·∫°c (ch·∫∑n auto-play)"));
                    console.log("‚ñ∂Ô∏è Music Resumed");
                } else {
                    bgMusic.pause();
                    console.log("II Music Paused");
                }
            }
            
            // Ph√≠m R (Restart)
            if (e.code === 'KeyR') {
                bgMusic.currentTime = 0; // Tua v·ªÅ 0
                bgMusic.play().catch(() => {});
                console.log("üîÑ Music Restarted");
            }
        });

        // 5. Th·ª≠ t·ª± ƒë·ªông ph√°t (Auto-play)
        // L∆∞u √Ω: Tr√¨nh duy·ªát (Chrome/Edge) th∆∞·ªùng ch·∫∑n t·ª± ph√°t n·∫øu ch∆∞a click chu·ªôt.
        // Code n√†y s·∫Ω th·ª≠ ph√°t, n·∫øu th·∫•t b·∫°i s·∫Ω ch·ªù c√∫ click ƒë·∫ßu ti√™n c·ªßa b·∫°n.
        bgMusic.play().catch(error => {
            console.log("‚è≥ Tr√¨nh duy·ªát ch·∫∑n t·ª± ph√°t. ƒêang ch·ªù ng∆∞·ªùi d√πng t∆∞∆°ng t√°c...");
            // L·∫Øng nghe c√∫ click ƒë·∫ßu ti√™n v√†o m√†n h√¨nh ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫°c
            window.addEventListener('click', function() {
                if (bgMusic.paused) {
                    bgMusic.play();
                }
            }, { once: true }); // Ch·ªâ ch·∫°y 1 l·∫ßn duy nh·∫•t
        });
        // ==========================================

        // =============================================
        // 5. ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            // 1. Xoay Camera/Object (ƒê√É S·ª¨A: T·ª∞ XOAY KHI KH√îNG C√ì TAY)
            const showHologram = (STATE.isPinching && (Date.now() - STATE.pinchStartTime > 1500));
            
            if(showHologram){
                // TR∆Ø·ªúNG H·ª¢P 1: ƒêANG M·ªû QU√Ä -> B·∫Øt bu·ªôc xoay v·ªÅ ch√≠nh di·ªán (0)
                // S·ªë 0.1 l√† t·ªëc ƒë·ªô xoay v·ªÅ gi·ªØa (nhanh h∆°n b√¨nh th∆∞·ªùng ch√∫t cho m∆∞·ª£t)
                treeGroup.rotation.y += (0 - treeGroup.rotation.y) * 0.1;
            }
            else if (STATE.handDetected) {
                // TR∆Ø·ªúNG H·ª¢P 2 C√ì TAY:
                
                // N·∫øu ch∆∞a m·ªü qu√† -> Xoay c√¢y theo v·ªã tr√≠ tay (tr√°i/ph·∫£i)
                // (STATE.handX - 0.5) * 2 gi√∫p xoay t·ª´ -1 ƒë·∫øn 1 radian
                let targetRot = (STATE.handX - 0.5) * 2;
                // D√πng c√¥ng th·ª©c n√†y ƒë·ªÉ camera l∆∞·ªõt theo tay m∆∞·ª£t m√† (kh√¥ng b·ªã gi·∫≠t)
                treeGroup.rotation.y += (targetRot - treeGroup.rotation.y) * 0.05;
                
                
            } else {
                // TR∆Ø·ªúNG H·ª¢P KH√îNG C√ì TAY:
                // T·ª± ƒë·ªông xoay tr√≤n ƒë·ªÅu
                treeGroup.rotation.y += 0.003; // TƒÉng s·ªë n√†y n·∫øu mu·ªën xoay nhanh h∆°n (vd: 0.01)
            }

            star.material.rotation -= 0.05;

            // 2. Logic ƒêi·ªÅu khi·ªÉn H·∫°t
            let morphSpeed = 0.08;
            const pp = particles.geometry.attributes.position.array;
            const cc = particles.geometry.attributes.color.array;
            let activeTargetColor = null; 

            // --- C·∫¨P NH·∫¨T TUY·∫æT R∆†I (Ch·ªâ c·∫≠p nh·∫≠t d·ªØ li·ªáu g·ªëc posTree) ---
            // Ch·ªâ l√†m tuy·∫øt r∆°i n·∫øu KH√îNG ph·∫£i ƒëang hi·ªÉn th·ªã ·∫¢NH (V√¨ ·∫£nh c·∫ßn h·∫°t ƒë·ª©ng y√™n ƒë·ªÉ x·∫øp h√¨nh)
            const isShowingPhoto = (STATE.activeItem && STATE.activeItem.includes('LETTER') && STATE.isPinching && (Date.now() - STATE.pinchStartTime > 1500));
            
            if (!isShowingPhoto) {
                for(let i = snowStartIndex; i < particleCount; i++) {
                    // Cho h·∫°t r∆°i xu·ªëng (gi·∫£m Y)
                    posTree[i*3+1] -= 0.15; // T·ªëc ƒë·ªô r∆°i
                    
                    // N·∫øu r∆°i th·∫•p qu√° (-50) th√¨ ƒë∆∞a l√™n ƒë·ªânh l·∫°i (50)
                    if(posTree[i*3+1] < -50) {
                        posTree[i*3+1] = 50;
                    }
                }
            }

            function getTarget(idx) {
                // 1. X·ª≠ l√Ω HOLOGRAM (∆Øu ti√™n cao nh·∫•t)
                if (STATE.handDetected && STATE.isPinching && (Date.now() - STATE.pinchStartTime > 1500)) {
                    
                    if(STATE.activeItem === 'LETTER_1') activeTargetColor = colTargetLetter1;
                    else if(STATE.activeItem === 'LETTER_2') activeTargetColor = colTargetLetter2;
                    else if(STATE.activeItem === 'GIFT_L') activeTargetColor = colTargetGiftL;
                    else if(STATE.activeItem === 'GIFT_C') activeTargetColor = colTargetGiftC;
                    else if(STATE.activeItem === 'GIFT_R') activeTargetColor = colTargetGiftR;
                    else activeTargetColor = baseColors;

                    switch(STATE.activeItem) {
                        case 'GIFT_L': 
                        case 'GIFT_C': 
                        case 'GIFT_R': 
                            // RI√äNG V·ªöI QU√Ä (CH·ªÆ):
                            // N·∫øu h·∫°t n√†y thu·ªôc v·ªÅ nh√≥m Tuy·∫øt (idx >= snowStartIndex) -> Cho n√≥ ti·∫øp t·ª•c r∆°i (tr·∫£ v·ªÅ posTree)
                            // N·∫øu h·∫°t n√†y thu·ªôc v·ªÅ Text (ƒë∆∞·ª£c d√πng trong Text) -> N√≥ s·∫Ω bay v·ªÅ v·ªã tr√≠ Text (do logic b√™n d∆∞·ªõi x·ª≠ l√Ω)
                            // Tuy nhi√™n, Text ch·ªâ d√πng v√†i ngh√¨n h·∫°t ƒë·∫ßu, h·∫°t tuy·∫øt ·ªü cu·ªëi d√£y.
                            if (idx >= snowStartIndex) return posTree; // Tuy·∫øt v·∫´n r∆°i
                            
                            // Tr·∫£ v·ªÅ v·ªã tr√≠ ch·ªØ t∆∞∆°ng ·ª©ng
                            if (STATE.activeItem === 'GIFT_L') return posTargetGiftL;
                            if (STATE.activeItem === 'GIFT_C') return posTargetGiftC;
                            return posTargetGiftR;

                        case 'LETTER_1': return posTargetLetter1; // ·∫¢nh c·∫ßn t·∫•t c·∫£ h·∫°t
                        case 'LETTER_2': return posTargetLetter2; // ·∫¢nh c·∫ßn t·∫•t c·∫£ h·∫°t
                        default: return posTree;
                    }
                }
                
                activeTargetColor = null; 

                // 2. X·ª≠ l√Ω N·ªî V·∫¨T PH·∫®M
                if (STATE.handDetected && STATE.isPinching && STATE.activeItem) {
                    const range = STATE.itemRanges[STATE.activeItem.toLowerCase()];
                    if (range && idx >= range[0] && idx <= range[1]) {
                        return posSphere; 
                    }
                }

                // 3. LOGIC CH√çNH
                if (STATE.handDetected && STATE.isHandOpen) {
                    STATE.lastMode = 'TREE'; 
                    return posTree; 
                }

                if(STATE.lastMode === 'TREE') return posTree;
                return posSphere; 
            }

            for(let i=0; i<particleCount; i++) {
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                const t = getTarget(i); 
                
                pp[ix] += (t[ix] - pp[ix]) * morphSpeed;
                pp[iy] += (t[iy] - pp[iy]) * morphSpeed;
                pp[iz] += (t[iz] - pp[iz]) * morphSpeed;

                const targetC = activeTargetColor ? activeTargetColor : baseColors;
                cc[ix] += (targetC[ix] - cc[ix]) * morphSpeed;     
                cc[iy] += (targetC[iy] - cc[iy]) * morphSpeed;    
                cc[iz] += (targetC[iz] - cc[iz]) * morphSpeed;     
            }

            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true; // [M·ªöI] B·∫Øt bu·ªôc c√≥ d√≤ng n√†y ƒë·ªÉ c·∫≠p nh·∫≠t m√†u

            // 3. Tuy·∫øt r∆°i
            const sp = scene.children[scene.children.length-1].geometry.attributes.position.array; 
            for(let i=0;i<snowCnt;i++){sp[i*3+1]-=snVel[i];if(sp[i*3+1]<-50)sp[i*3+1]=50;}
            scene.children[scene.children.length-1].geometry.attributes.position.needsUpdate=true;

            // 4. Sao
            const isHologram = (STATE.isPinching && (Date.now() - STATE.pinchStartTime > 1500));
            const showStar = (!isHologram && STATE.lastMode === 'TREE');
            const sScale = showStar ? 7.0 : 0.0;
            star.scale.setScalar(THREE.MathUtils.lerp(star.scale.x, sScale, 0.1));
            star.material.opacity = THREE.MathUtils.lerp(star.material.opacity, showStar?1:0, 0.1);

            renderer.render(scene, camera);
        }
        animate();
        window.onresize=()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);};
    </script>
</body>
</html>